package studio.forface.ermes.servicefactory

import studio.forface.ermes.annotations.ApiService
import studio.forface.ermes.api.CallAdapter
import studio.forface.ermes.api.ErmesApi
import studio.forface.ermes.entities.Endpoint
import studio.forface.ermes.entities.Url
import studio.forface.ermes.exceptions.MissingAnnotationException
import studio.forface.ermes.utils.findAnnotation
import studio.forface.ermes.utils.realFunctions
import kotlin.properties.ReadOnlyProperty
import kotlin.reflect.KClass
import kotlin.reflect.KFunction
import kotlin.reflect.KProperty

/**
 * @author Davide Giuseppe Farella.
 * A class that will created the implementation of the requested Service [S].
 *
 * @param S the return type of [invoke]
 * @param ermesApi required for retrieve Api info, such as [ErmesApi.baseUrl]
 * @param serviceKlass the Class of the requested Service [S] used for reflection and required since [S] will be erased
 * at runtime.
 *
 * @throws MissingAnnotationException
 * @see apiServiceAnnotationWorker
 *
 * @throws Exception
 * @see serviceFunctions
 */
@PublishedApi
internal class ServiceFactory( ermesApi: ErmesApi, private val serviceKlass: KClass<*> ) {

    /**
     * An instance of [ApiServiceAnnotationWorker]
     * @throws MissingAnnotationException if [serviceKlass] is not annotated with [ApiService]
     */
    private val apiServiceAnnotationWorker = ApiServiceAnnotationWorker(
        serviceKlass.findAnnotation<ApiService>() ?: throw MissingAnnotationException(
            "The service must be annotated with ${ApiService::class.qualifiedName}"
        )
    )

    /** A validated base [Url], ( with the [Endpoint] if not null ) for the calls */
    val baseUrl = ermesApi.baseUrl + apiServiceAnnotationWorker.endpoint

    /** The [ErmesApi.callAdapter] */
    val callAdapter = ermesApi.callAdapter

    /** The [ErmesApi.client] */
    val client = ermesApi.client

    /**
     * All the declared [realFunctions] of [serviceKlass]
     *
     * @throws Exception
     * @see CallAdapter.assertValidFunction
     */
    val serviceFunctions = serviceKlass.realFunctions
        .also { it.forEach { f -> callAdapter.assertValidFunction( f ) } }

    /** Create an implementation at runtime of the requested Service [S] */
    inline operator fun <reified S : Any> invoke() : S {

        val httpCallInvoker = HttpCallInvoker( client )

        val functionInvocationHandlers = serviceFunctions
            .map { it to FunctionWorker( it, baseUrl ) }
            .toMap()

        return makeProxy( callAdapter, functionInvocationHandlers, httpCallInvoker )
    }
}

/** Platform dependant creation of Proxy */
@PublishedApi
internal expect inline fun <reified S : Any> ServiceFactory.makeProxy(
    callAdapter: CallAdapter,
    functionInvocationHandlers: Map<KFunction<*>, FunctionWorker>,
    httpCallInvoker: HttpCallInvoker
) : S

/**
 * Create a Service by property delegation
 * @return [ReadOnlyProperty] representing the implementation of the requested [S], generated by [ServiceFactory].
 */
inline fun <reified S : Any> ErmesApi.service() = object : ReadOnlyProperty<ErmesApi, S> {

    /** A lazy value for the Service [S] */
    private val value: S by lazy { this@service<S>() }

    /**
     * @see ReadOnlyProperty.getValue
     * @return [value]
     */
    override fun getValue( thisRef: ErmesApi, property: KProperty<*>): S = value
}